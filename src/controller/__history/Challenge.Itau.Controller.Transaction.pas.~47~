unit Challenge.Itau.Controller.Transaction;

interface

uses
  System.SysUtils,
  System.JSON,
  Horse,
  Challenge.Itau.Service.Transaction,
  Challenge.Itau.Model.Exceptions;

procedure RegisterRoutes;
procedure ConfigCORS(Req: THorseRequest; Res: THorseResponse; Next: TNextProc);

implementation

procedure InsertTransaction(Req: THorseRequest; Res: THorseResponse; Next: TProc);
var
  LService: TChallengeItauServiceTransaction;
begin
  LService := TChallengeItauServiceTransaction.Create;
  try
    try
      LService.Insert(Req.Body<TJSONObject>);
      Res.Status(THTTPSTatus.Created);
    except
      on E: EValidationError do
      begin
        Writeln('Erro de validação: ', E.Message);
        Res.Send<TJSONObject>(
          TJSONObject.Create
            .AddPair('status', 'error')
            .AddPair('message', E.Message)
        ).Status(THTTPStatus.UnprocessableEntity);
      end;
      on E: EJSONValidationError do
      begin
        Writeln('Erro de validação do JSON: ', E.Message);
        Res.Send<TJSONObject>(
          TJSONObject.Create
            .AddPair('status', 'error')
            .AddPair('message', E.Message)
        ).Status(THTTPStatus.BadRequest);
      end;
      on E: Exception do
      begin
        Writeln('Erro interno: ', E.Message);
        Res.Send<TJSONObject>(
          TJSONObject.Create
            .AddPair('status', 'error')
            .AddPair('message', E.Message)
        ).Status(THTTPStatus.InternalServerError);
      end;
    end;
  finally
    LService.Free;
  end;
end;

procedure DeleteTransaction(Req: THorseRequest; Res: THorseResponse; Next: TProc);
var
  LService: TChallengeItauServiceTransaction;
begin
  LService := TChallengeItauServiceTransaction.Create;
  try
    try
      LService.Delete;
      Res.Status(THTTPSTatus.OK);
    except
      on E: EValidationError do
      begin
        Writeln('Erro de validação: ', E.Message);
        Res.Send<TJSONObject>(
          TJSONObject.Create
            .AddPair('status', 'error')
            .AddPair('message', E.Message)
        ).Status(THTTPStatus.UnprocessableEntity);
      end;
      on E: EJSONValidationError do
      begin
        Writeln('Erro de validação do JSON: ', E.Message);
        Res.Send<TJSONObject>(
          TJSONObject.Create
            .AddPair('status', 'error')
            .AddPair('message', E.Message)
        ).Status(THTTPStatus.BadRequest);
      end;
      on E: Exception do
      begin
        Writeln('Erro interno: ', E.Message);
        Res.Send<TJSONObject>(
          TJSONObject.Create
            .AddPair('status', 'error')
            .AddPair('message', E.Message)
        ).Status(THTTPStatus.InternalServerError);
      end;
    end;
  finally
    LService.Free;
  end;
end;

procedure ConfigCORS(Req: THorseRequest; Res: THorseResponse; Next: TNextProc);
var
  LAllowedOrigin, LAllowedCredentials, LAllowedHeaders,
  LAllowedMethods, LExposedHeaders: string;
begin
  LAllowedOrigin := '*';
  LAllowedCredentials := 'true';
  LAllowedHeaders := 'Content-Type, Authorization, Accept';
  LAllowedMethods := 'GET, POST, PUT, DELETE, OPTIONS';
  LExposedHeaders := '*';

  Res.RawWebResponse.SetCustomHeader('Access-Control-Allow-Origin', LAllowedOrigin);
  Res.RawWebResponse.SetCustomHeader('Access-Control-Allow-Credentials', LAllowedCredentials);
  Res.RawWebResponse.SetCustomHeader('Access-Control-Allow-Headers', LAllowedHeaders);
  Res.RawWebResponse.SetCustomHeader('Access-Control-Allow-Methods', LAllowedMethods);
  Res.RawWebResponse.SetCustomHeader('Access-Control-Expose-Headers', LExposedHeaders);

  if Req.RawWebRequest.Method = 'OPTIONS' then
  begin
    Writeln('Interceptando requisição OPTIONS, encerrando fluxo.');
    Res.Status(THTTPStatus.OK).Send('OK');
    Exit;
  end;

  Next();
end;


procedure RegisterRoutes;
begin
  THorse.Post('/transacao', InsertTransaction);
  THorse.Delete('/transacao', DeleteTransaction);
end;

end.
